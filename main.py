import telebot
from telebot import types
from flask import Flask, request
import json
import os

# ====== Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ======
TOKEN = "8317743306:AAFGH1Acxb6fIwZ0o0T2RvNjezQFW8KWcw8"
ADMIN_ID = 7625893170
SYRIATEL_CODE = "82492253"
SHAM_CODE = "131efe4fbccd83a811282761222eee69"
SITE_LINK = "https://www.55bets.net/#/casino/"
RENDER_URL = "https://telegram-bot-xsto.onrender.com"
DATA_FILE = "data.json"
MIN_AMOUNT = 25000

# ====== Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ======
pending_accounts = {}        # { user_id: {"user_text": "..."} } Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
pending_deposits = {}        # { user_id: {account, amount, method, file_id} }
pending_withdraws = {}       # { user_id: {amount, method, wallet} }
pending_deletes = {}         # { user_id: {account} }

bot = telebot.TeleBot(TOKEN)
app = Flask(__name__)

# ====== Ø­ÙØ¸ ÙˆÙ‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ======
def load_data():
    if not os.path.exists(DATA_FILE) or os.path.getsize(DATA_FILE) == 0:
        return {"user_accounts": {}, "pending_deposits": {}, "pending_withdraws": {}, "pending_deletes": {}}
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            return {"user_accounts": {}, "pending_deposits": {}, "pending_withdraws": {}, "pending_deletes": {}}

def save_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

# ====== Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ======
def main_menu(chat_id, include_create=False):
    markup = types.InlineKeyboardMarkup()
    markup.add(
        types.InlineKeyboardButton("ğŸ’³ Ø´Ø­Ù† Ø§Ù„Ø­Ø³Ø§Ø¨", callback_data="deposit"),
        types.InlineKeyboardButton("ğŸ’¸ Ø³Ø­Ø¨", callback_data="withdraw")
    )
    if include_create:
        markup.add(types.InlineKeyboardButton("ğŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨", callback_data="create_account"))
    markup.add(
        types.InlineKeyboardButton("ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨", callback_data="delete_account"),
        types.InlineKeyboardButton("ğŸ“ Ø§Ù„Ø¯Ø¹Ù…", callback_data="support")
    )
    return markup

def back_to_menu():
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu"))
    return markup

def admin_controls(user_id):
    """Ø£Ø²Ø±Ø§Ø± ØªØ¸Ù‡Ø± Ù„Ù„Ø¥Ø¯Ù…Ù† Ù…Ø¹ user_id Ø¯Ø§Ø®Ù„ callback_data"""
    markup = types.InlineKeyboardMarkup()
    markup.add(
        types.InlineKeyboardButton("âœ… Ù‚Ø¨ÙˆÙ„", callback_data=f"admin_accept_{user_id}"),
        types.InlineKeyboardButton("âŒ Ø±ÙØ¶", callback_data=f"admin_reject_{user_id}"),
        types.InlineKeyboardButton("ğŸ’¬ Ø±Ø¯ ÙŠØ¯ÙˆÙŠ", callback_data=f"admin_manual_{user_id}")
    )
    return markup

def check_min_amount(amount):
    try:
        return int(amount) >= MIN_AMOUNT
    except:
        return False

# ====== /start ======
@bot.message_handler(commands=['start'])
def start(message):
    data = load_data()
    user_id = str(message.chat.id)
    if user_id in data["user_accounts"]:
        markup = main_menu(message.chat.id)
        bot.send_message(message.chat.id, f"ğŸ‘¤ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹.\nØ§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=markup)
    else:
        markup = main_menu(message.chat.id, include_create=True)
        text = f"ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… [55BETS]({SITE_LINK})!\nØ§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡:"
        bot.send_message(message.chat.id, text, reply_markup=markup, parse_mode="Markdown")

# ====== Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© (callback) ======
@bot.callback_query_handler(func=lambda call: call.data == "main_menu")
def show_main_menu(call):
    bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    data = load_data()
    user_id = str(call.message.chat.id)
    include_create = user_id not in data["user_accounts"]
    bot.send_message(call.message.chat.id, "ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=main_menu(call.message.chat.id, include_create=include_create))

# ====== Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ ======
@bot.callback_query_handler(func=lambda call: call.data == "create_account")
def create_account(call):
    bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    data = load_data()
    user_id = str(call.message.chat.id)
    if user_id in data["user_accounts"]:
        bot.answer_callback_query(call.id, "âŒ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¨Ù‚ØŒ Ø§Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø£ÙˆÙ„Ø§Ù‹.")
        return
    # Ù†Ø·Ù„Ø¨ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Username Ùˆ Password
    msg = bot.send_message(
        call.message.chat.id,
        "ğŸ“ Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ø¨ØµÙŠØºØ© (Ø³Ø·Ø±ÙŠÙ†):\nUsername: Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨\nPassword: ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±",
        reply_markup=back_to_menu()
    )
    bot.register_next_step_handler(msg, process_account_info)

def process_account_info(message):
    # Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¹Ø¨Ø± ÙƒÙˆÙ„Ø¨Ø§Ùƒ handled separately; Ù‡Ù†Ø§ Ù†ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Øµ
    if message.text and message.text.strip().lower() == "ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        bot.send_message(message.chat.id, "ğŸ”™ Ø¹Ø¯Øª Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.", reply_markup=main_menu(message.chat.id))
        return
    user_id = str(message.chat.id)
    text = message.text or ""
    lines = text.split("\n")
    username_line = next((l for l in lines if l.strip().startswith("Username:")), None)
    password_line = next((l for l in lines if l.strip().startswith("Password:")), None)
    if not username_line or not password_line:
        msg = bot.send_message(message.chat.id, "âŒ Ø§Ù„ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©. ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ØµÙŠØºØ©:\nUsername: Ø§Ø³Ù…\nPassword: ÙƒÙ„Ù…Ø©", reply_markup=back_to_menu())
        bot.register_next_step_handler(msg, process_account_info)
        return
    # Ø®Ø²Ù‘Ù† Ø§Ù„Ø·Ù„Ø¨ Ù…Ø¤Ù‚ØªÙ‹Ø§ (Ù†Ø®Ø²Ù† Ù†Øµ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù…Ø±Ø¬Ø¹ÙŠØªÙ‡)
    pending_accounts[user_id] = {"user_text": text}
    # Ø£Ø±Ø³Ù„ Ù„Ù„Ø¥Ø¯Ù…Ù† Ù…Ø¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… (Ø§Ù„Ø¥Ø¯Ù…Ù† Ø³ÙŠØ¶ØºØ· Ù‚Ø¨ÙˆÙ„ Ø«Ù… ÙŠØ±Ø³Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ)
    bot.send_message(
        ADMIN_ID,
        f"ğŸ“© Ø·Ù„Ø¨ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯:\nğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\n\n{text}",
        reply_markup=admin_controls(user_id)
    )
    bot.send_message(message.chat.id, "â³ ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...", reply_markup=main_menu(user_id))

# ====== Ø´Ø­Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ ======
@bot.callback_query_handler(func=lambda call: call.data.startswith("deposit_") or call.data == "deposit")
def deposit_handler(call):
    # Ù…Ø³Ø­ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    user_id = str(call.message.chat.id)
    data = load_data()
    if user_id not in data["user_accounts"]:
        bot.send_message(user_id, "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŒ ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø£ÙˆÙ„Ø§Ù‹.", reply_markup=main_menu(user_id, include_create=True))
        return
    # Ø§Ø¯Ø®Ù„ Ø§Ù„Ù…Ø¨Ù„Øº
    msg = bot.send_message(call.message.chat.id, f"ğŸ’° Ø£Ø¯Ø®Ù„ Ø§Ù„Ù…Ø¨Ù„Øº Ù„Ø´Ø­Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ {MIN_AMOUNT}):", reply_markup=back_to_menu())
    bot.register_next_step_handler(msg, deposit_amount_step)

def deposit_amount_step(message):
    if message.text and message.text.strip().lower() == "ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        bot.send_message(message.chat.id, "ğŸ”™ Ø¹Ø¯Øª Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.", reply_markup=main_menu(message.chat.id))
        return
    amount = message.text.strip()
    if not check_min_amount(amount):
        msg = bot.send_message(message.chat.id, f"âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø´Ø­Ù† Ù‡Ùˆ {MIN_AMOUNT}. Ø£Ø¹Ø¯ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº:", reply_markup=back_to_menu())
        bot.register_next_step_handler(msg, deposit_amount_step)
        return
    user_id = str(message.chat.id)
    data = load_data()
    account = data["user_accounts"].get(user_id, user_id)
    markup = types.InlineKeyboardMarkup()
    markup.add(
        types.InlineKeyboardButton("Ø³ÙŠØ±ÙŠØ§ØªÙŠÙ„ ÙƒØ§Ø´", callback_data=f"deposit_syriatel_{amount}"),
        types.InlineKeyboardButton("Ø´Ø§Ù… ÙƒØ§Ø´", callback_data=f"deposit_sham_{amount}")
    )
    bot.send_message(message.chat.id, f"ğŸ’³ Ø³ÙŠØªÙ… Ø´Ø­Ù† Ø§Ù„Ø­Ø³Ø§Ø¨: {account}\nØ§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith("deposit_syriatel_") or call.data.startswith("deposit_sham_"))
def deposit_method_selected(call):
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    parts = call.data.split("_")
    method = parts[1]   # syriatel or sham
    amount = parts[2]
    user_id = str(call.message.chat.id)
    method_name = "Ø³ÙŠØ±ÙŠØ§ØªÙŠÙ„ ÙƒØ§Ø´" if method == "syriatel" else "Ø´Ø§Ù… ÙƒØ§Ø´"
    code = SYRIATEL_CODE if method == "syriatel" else SHAM_CODE
    bot.send_message(call.message.chat.id, f"ğŸ“± ÙƒÙˆØ¯ Ø§Ù„Ù…Ø­ÙØ¸Ø© Ù„Ù€ {method_name}: `{code}`\nğŸ“¸ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹.", parse_mode="Markdown")
    bot.register_next_step_handler(call.message, lambda m: confirm_deposit_image(m, amount, method_name))

def confirm_deposit_image(message, amount, method_name):
    if not message.photo:
        bot.send_message(message.chat.id, "âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹ ÙÙ‚Ø·.", reply_markup=main_menu(message.chat.id))
        return
    file_id = message.photo[-1].file_id
    user_id = str(message.chat.id)
    # Ø­ÙØ¸ Ø·Ù„Ø¨ Ø§Ù„Ø´Ø­Ù† Ù…Ø¤Ù‚ØªÙ‹Ø§
    pending_deposits[user_id] = {"amount": amount, "method": method_name, "file_id": file_id}
    # Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø§Ø¯Ù…Ù† Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
    bot.send_photo(
        ADMIN_ID,
        file_id,
        caption=f"ğŸ’³ Ø·Ù„Ø¨ Ø´Ø­Ù† Ø¬Ø¯ÙŠØ¯:\nğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: {amount}\nğŸ’¼ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©: {method_name}",
        reply_markup=admin_controls(user_id)
    )
    bot.send_message(message.chat.id, "ğŸ“© ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„Ø´Ø­Ù† Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.", reply_markup=main_menu(message.chat.id))

# ====== Ø³Ø­Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨ ======
@bot.callback_query_handler(func=lambda call: call.data.startswith("withdraw_") or call.data == "withdraw")
def withdraw_handler(call):
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    user_id = str(call.message.chat.id)
    data = load_data()
    if user_id not in data["user_accounts"]:
        bot.send_message(user_id, "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŒ ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø£ÙˆÙ„Ø§Ù‹.", reply_markup=main_menu(user_id, include_create=True))
        return
    msg = bot.send_message(call.message.chat.id, f"ğŸ’° Ø£Ø¯Ø®Ù„ Ø§Ù„Ù…Ø¨Ù„Øº Ù„Ù„Ø³Ø­Ø¨ (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ {MIN_AMOUNT}):", reply_markup=back_to_menu())
    bot.register_next_step_handler(msg, withdraw_amount_step)

def withdraw_amount_step(message):
    if message.text and message.text.strip().lower() == "ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        bot.send_message(message.chat.id, "ğŸ”™ Ø¹Ø¯Øª Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.", reply_markup=main_menu(message.chat.id))
        return
    amount = message.text.strip()
    if not check_min_amount(amount):
        msg = bot.send_message(message.chat.id, f"âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø³Ø­Ø¨ Ù‡Ùˆ {MIN_AMOUNT}. Ø£Ø¹Ø¯ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº:", reply_markup=back_to_menu())
        bot.register_next_step_handler(msg, withdraw_amount_step)
        return
    markup = types.InlineKeyboardMarkup()
    markup.add(
        types.InlineKeyboardButton("Ø³ÙŠØ±ÙŠØ§ØªÙŠÙ„ ÙƒØ§Ø´", callback_data=f"withdraw_syriatel_{amount}"),
        types.InlineKeyboardButton("Ø´Ø§Ù… ÙƒØ§Ø´", callback_data=f"withdraw_sham_{amount}")
    )
    bot.send_message(message.chat.id, "ğŸ’³ Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø³Ø­Ø¨:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith("withdraw_syriatel_") or call.data.startswith("withdraw_sham_"))
def withdraw_method_selected(call):
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    parts = call.data.split("_")
    method = parts[1]  # syriatel or sham
    amount = parts[2]
    user_id = str(call.message.chat.id)
    method_name = "Ø³ÙŠØ±ÙŠØ§ØªÙŠÙ„ ÙƒØ§Ø´" if method == "syriatel" else "Ø´Ø§Ù… ÙƒØ§Ø´"
    # Ù†Ø·Ù„Ø¨ Ø±Ù‚Ù…/ÙƒÙˆØ¯ Ø§Ù„Ù…Ø­ÙØ¸Ø©
    msg = bot.send_message(call.message.chat.id, f"ğŸ“© Ø£Ø±Ø³Ù„ Ø±Ù‚Ù…/ÙƒÙˆØ¯ Ø§Ù„Ù…Ø­ÙØ¸Ø© Ù„Ù„Ø·Ø±ÙŠÙ‚Ø© {method_name}:", reply_markup=back_to_menu())
    bot.register_next_step_handler(msg, lambda m: confirm_withdraw_wallet(m, amount, method_name))

def confirm_withdraw_wallet(message, amount, method_name):
    if message.text and message.text.strip().lower() == "ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        bot.send_message(message.chat.id, "ğŸ”™ Ø¹Ø¯Øª Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.", reply_markup=main_menu(message.chat.id))
        return
    wallet = message.text.strip()
    user_id = str(message.chat.id)
    pending_withdraws[user_id] = {"amount": amount, "method": method_name, "wallet": wallet}
    # Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¥Ø¯Ù…Ù† Ù…Ø¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
    bot.send_message(
        ADMIN_ID,
        f"ğŸ’¸ Ø·Ù„Ø¨ Ø³Ø­Ø¨ Ø¬Ø¯ÙŠØ¯:\nğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}\nğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: {amount}\nğŸ’¼ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©: {method_name}\nğŸ“¥ Ø§Ù„Ù…Ø­ÙØ¸Ø©: {wallet}",
        reply_markup=admin_controls(user_id)
    )
    bot.send_message(message.chat.id, "ğŸ“© ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„Ø³Ø­Ø¨ Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.", reply_markup=main_menu(message.chat.id))

# ====== Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ ======
@bot.callback_query_handler(func=lambda call: call.data == "delete_account")
def delete_account(call):
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    user_id = str(call.message.chat.id)
    data = load_data()
    if user_id not in data["user_accounts"]:
        bot.send_message(user_id, "âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨.", reply_markup=main_menu(user_id, include_create=True))
        return
    pending_deletes[user_id] = {"account": data["user_accounts"][user_id]}
    bot.send_message(ADMIN_ID, f"ğŸ—‘ï¸ Ø·Ù„Ø¨ Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨:\nğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}", reply_markup=admin_controls(user_id))
    bot.send_message(user_id, "ğŸ“© ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.", reply_markup=main_menu(user_id))

# ====== Ø§Ù„Ø¯Ø¹Ù… ======
@bot.callback_query_handler(func=lambda call: call.data == "support")
def support_handler(call):
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    msg = bot.send_message(call.message.chat.id, "ğŸ“© Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ Ù„Ù„Ø¯Ø¹Ù…:", reply_markup=back_to_menu())
    bot.register_next_step_handler(msg, send_support_message)

def send_support_message(message):
    if message.text and message.text.strip().lower() == "ğŸ”™ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        bot.send_message(message.chat.id, "ğŸ”™ Ø¹Ø¯Øª Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.", reply_markup=main_menu(message.chat.id))
        return
    user_id = str(message.chat.id)
    bot.send_message(ADMIN_ID, f"ğŸ“© Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}:\n{message.text}", reply_markup=admin_controls(user_id))
    bot.send_message(message.chat.id, "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¥Ù„Ù‰ Ø§Ù„Ø¯Ø¹Ù…. Ø³ØªØªÙ„Ù‚Ù‰ Ø§Ù„Ø±Ø¯ Ù‚Ø±ÙŠØ¨Ù‹Ø§.", reply_markup=main_menu(message.chat.id))

# ====== Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø¥Ø¯Ù…Ù† (callbacks) ======
@bot.callback_query_handler(func=lambda call: call.data.startswith("admin_"))
def admin_action(call):
    parts = call.data.split("_")
    action = parts[1]      # accept / reject / manual
    user_id = parts[2]

    # Ù„Ø§ Ù†Ø­Ø°Ù Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¯Ù…Ù† - ØªØ¨Ù‚Ù‰ Ù…ØªØ§Ø­Ø©
    if action == "manual":
        msg = bot.send_message(ADMIN_ID, f"ğŸ“ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}:")
        bot.register_next_step_handler(msg, lambda m: send_manual_reply(m, user_id))

    elif action == "accept":
        # Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ù‚Ø¨ÙˆÙ„ØŒ Ù†Ø·Ù„Ø¨ Ù…Ù† Ø§Ù„Ø§Ø¯Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ (Username & Password)
        msg = bot.send_message(ADMIN_ID, f"ğŸ†• Ø§Ø±Ø³Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id} Ø¨ØµÙŠØºØ©:\nUsername: Ø§Ø³Ù…\nPassword: ÙƒÙ„Ù…Ø©\n\n(ÙŠÙ…ÙƒÙ†Ùƒ ØªØ±Ùƒ Password ÙØ§Ø±ØºØ© ÙˆØ³ÙŠØªÙ… ÙˆØ¶Ø¹ ********)")
        bot.register_next_step_handler(msg, lambda m: save_new_account_from_admin(m, user_id))

    elif action == "reject":
        try:
            bot.send_message(int(user_id), "âŒ ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨Ùƒ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.", reply_markup=main_menu(int(user_id)))
        except:
            pass
        if user_id in pending_accounts:
            del pending_accounts[user_id]
        if user_id in pending_deposits:
            del pending_deposits[user_id]
        if user_id in pending_withdraws:
            del pending_withdraws[user_id]
        if user_id in pending_deletes:
            del pending_deletes[user_id]
        bot.send_message(ADMIN_ID, f"âœ… ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}.")

def send_manual_reply(message, user_id):
    try:
        bot.send_message(int(user_id), f"ğŸ“© Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©:\n{message.text}", reply_markup=main_menu(int(user_id)))
        bot.send_message(ADMIN_ID, "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù….")
    except Exception as e:
        bot.send_message(ADMIN_ID, f"âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")

def save_new_account_from_admin(message, user_id):
    """ÙŠØ­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙŠ Ø£Ø±Ø³Ù„Ù‡Ø§ Ø§Ù„Ø¥Ø¯Ù…Ù† Ø¨Ø¹Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ù‚Ø¨ÙˆÙ„"""
    text = message.text or ""
    lines = text.split("\n")
    username_line = next((l for l in lines if l.strip().startswith("Username:")), None)
    password_line = next((l for l in lines if l.strip().startswith("Password:")), None)

    if not username_line:
        msg = bot.send_message(ADMIN_ID, "âš ï¸ Ù„Ù… Ø£Ø¬Ø¯ Ø³Ø·Ø± Username:. Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨ØµÙŠØºØ©:\nUsername: Ø§Ø³Ù…\nPassword: ÙƒÙ„Ù…Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)")
        bot.register_next_step_handler(msg, lambda m: save_new_account_from_admin(m, user_id))
        return

    username = username_line.split(":",1)[1].strip()
    password = password_line.split(":",1)[1].strip() if password_line else "********"

    # Ø§Ø­ÙØ¸ ÙÙŠ data.json
    data = load_data()
    data["user_accounts"][user_id] = {"username": username, "password": password}
    save_data(data)

    # Ø£Ø®Ø¨Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    try:
        bot.send_message(int(user_id), f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!\nUsername: {username}\nPassword: {password}", reply_markup=main_menu(int(user_id)))
    except:
        pass

    # ØªØ£ÙƒÙŠØ¯ Ù„Ù„Ø¥Ø¯Ù…Ù†
    bot.send_message(ADMIN_ID, f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}:\nUsername: {username}\nPassword: {password}")

    # ØªÙ†Ø¸ÙŠÙ Ø£ÙŠ Ø·Ù„Ø¨Ø§Øª Ù…Ø¤Ù‚ØªØ©
    if user_id in pending_accounts:
        del pending_accounts[user_id]
    if user_id in pending_deposits:
        del pending_deposits[user_id]
    if user_id in pending_withdraws:
        del pending_withdraws[user_id]
    if user_id in pending_deletes:
        del pending_deletes[user_id]

# ====== Webhook Flask ======
@app.route('/' + TOKEN, methods=['POST'])
def webhook():
    try:
        json_str = request.stream.read().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print("Webhook error:", e)
    return '', 200

@app.route('/')
def index():
    # set webhook when visiting root
    try:
        bot.remove_webhook()
        bot.set_webhook(url=RENDER_URL + '/' + TOKEN)
    except Exception as e:
        print("Webhook set error:", e)
    return "Webhook Set!"

if __name__ == "__main__":
    PORT = int(os.environ.get("PORT", 10000))
    app.run(host="0.0.0.0", port=PORT)
